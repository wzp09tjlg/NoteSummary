在安卓开发中经常会遇到进程的等级问题：
1、foreground process
    正处于activity resume状态
    正处于bound服务交互的状态
    正处于服务在前台运行的状态（StartForeGround（）被调用）
    Service生命周期正在被执行（onCreate（），onStart（），onDestroy（））
    BroadcastReceiver正在执行onReceive（）方法
    杀死foreground需要用户响应，因为这个安全优先级是最高的
    是用户操作所必须的，任一时间下，仅有少数进程会处于前台，仅当内存实在无法供给它们维持同时运行时才会被杀死。一般来说，在这种情况下，设备依然处于使用虚拟内存的状态，必须要杀死一些前台进程以用户界面保持响应。
•Android会依据进程中当前活跃组件的重要程度来尽可能高的估量一个进程的级别。比如说，如果一个进程中同时有一个服务和一个可视的activity，则进程会被判定为可视进程，而不是服务进程。
2、visible process
    activity不在前端显示，但也没有完全隐藏，能够看得见，比如弹出一个对话框
    一个bound到visible或者foreground的activity的service
    没有前台组件，但仍可被用户在屏幕上所见。当满足如下任一条件时，进程被认为是可视的：
• 它包含着一个不在前台，但仍然为用户可见的activity（它的onPause()方法被调用）。这种情况可能出现在以下情况：比如说，前台activity是一个对话框，而之前的    activity位于其下并可以看到。
• 它包含了一个绑定至一个可视的activity的服务。
可视进程依然被视为是很重要的，非到不杀死它们便无法维持前台进程运行时，才会被杀死。
3、Service process
    正在运行的，不在上述两种状态的service
是由 startService() 方法启动的服务，它不会变成上述两类。尽管服务进程不会直接为用户所见，但它们一般都在做着用户所关心的事情（比如在后台播放mp3或者从网上下载东 西）。所以系统会尽量维持它们的运行，除非系统内存不足以维持前台进程和可视进程的运行需要。
4、background process
    不可见状态的activity进程，onstop被调用
    包含目前不为用户所见的activity（Activity对象的 onStop() 方法已被调用）。这些进程与用户体验没有直接的联系，可以在任意时间被杀死以回收内存供前台进程、可视进程以及服务进程使用。一般来说，会有很多背景进程 运行，所以它们一般存放于一个LRU（最后使用）列表中以确保最后被用户使用的activity最后被杀死。如果一个activity正确的实现了生命周 期方法，并捕获了正确的状态，则杀死它的进程对用户体验不会有任何不良影响。
5、empty process
    没有运行任何component的进程，保留这个进程主要是为了缓存的需要
    不包含任何活动应用程序组件。这种进程存在的唯一原因是做为缓存以改善组件再次于其中运行时的启动时间。系统经常会杀死这种进程以保持进程缓存和系统内核缓存之间的平衡。
此外，一个进程的级别可能会由于其它进程依赖于它而升高。一个为其它进程提供 服务的进程级别永远高于使用它服务的进程。比如说，如果A进程中的内容提供者为进程B中的客户端提供服务，或进程A中的服务为进程B中的组件所绑定，则A 进程最低也会被视为与进程B拥有同样的重要性。

来源： <http://blog.csdn.net/llbupt/article/details/7358360>
 